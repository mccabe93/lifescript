import java.util.*;
import java.io.*;

/***		
	The InterpVisitor class is where we actually implement the behavior of our AST nodes. 
	Essentially, it will traverse the AST generated by our grammar (in conjunction with 
	the various node classes) and determine which operation to run based upon the type of 
	node we are given.

	Additionally, a hashmap is used to store and retrieve the variables, and a scanner is 
	used to receive input from the user.
	
NOTE:	Much of the implementation was in SIMPLE1MULTI and has been reused. All SIMPLE1MULTI
	code was written by Lutz Hamel. 

	These methods have been separated from those that were written from scratch for the 
	Mini2Basic language.
***/

public class InterpVisitor {
	public boolean saveStmts = true;
	private int generations = 3;
	private LSFrame simFrame;
	private CellMatrix cellMatrix;
	private ArrayList<AST> 	typeStmts = new ArrayList<AST>(), 
				worldStmts = new ArrayList<AST>();
	
	// our variable value memory.
	private HashMap memory = new HashMap();
	
	// Get the value of the variable
	private Scanner consoleInput = new Scanner(System.in);

	// the dispatcher for the interpreter visitor
	public Double dispatch(AST ast) {
		if      (ast.getClass() == AssignStmt.class)		return interp((AssignStmt)ast);
		else if (ast.getClass() == BlockStmt.class)		return interp((BlockStmt)ast);
		else if (ast.getClass() == IfStmt.class)		return interp((IfStmt)ast);
		else if (ast.getClass() == ForStmt.class)		return interp((ForStmt)ast);
		else if (ast.getClass() == InputStmt.class)		return interp((InputStmt)ast);
		else if (ast.getClass() == PrintStmt.class)		return interp((PrintStmt)ast);
		else if (ast.getClass() == EOLStmt.class)		return interp((EOLStmt)ast);
		else if (ast.getClass() == EndStmt.class)		return interp((EndStmt)ast);
		else if (ast.getClass() == WhileStmt.class)		return interp((WhileStmt)ast);
		else if (ast.getClass() == StmtList.class)		return interp((StmtList)ast);
		else if (ast.getClass() == CreateStmt.class)		return interp((CreateStmt)ast);
		else if (ast.getClass() == KillStmt.class)		return interp((KillStmt)ast);
		else if (ast.getClass() == PropertiesStmt.class)	return interp((PropertiesStmt)ast);
		else if (ast.getClass() == AliveStmt.class)		return interp((AliveStmt)ast);
		else if (ast.getClass() == DeadStmt.class)		return interp((DeadStmt)ast);
		else if (ast.getClass() == NeighborhoodStmt.class)	return interp((NeighborhoodStmt)ast);

		else if (ast.getClass() == TypeStmt.class)		return interp((TypeStmt)ast);
		else if (ast.getClass() == WorldStmt.class)		return interp((WorldStmt)ast);
		else if (ast.getClass() == NeighborExpr.class)		return interp((NeighborExpr)ast);
		else if (ast.getClass() == NeighborsExpr.class)		return interp((NeighborsExpr)ast);

		else if (ast.getClass() == BooleanExpr.class)		return interp((BooleanExpr)ast);
		else if (ast.getClass() == MathExpr.class)		return interp((MathExpr)ast);
		else if (ast.getClass() == NumExpr.class)		return interp((NumExpr)ast);
		else if (ast.getClass() == ParenExpr.class)		return interp((ParenExpr)ast);
		else if (ast.getClass() == VarExpr.class)		return interp((VarExpr)ast);
		else if (ast.getClass() == NegExpr.class)		return interp((NegExpr)ast);
		else {
		    System.out.println("PrettyPrintVisitor: unknown class type");
		    System.exit(1);
		    return null;
		}
	}

	public void setCellMatrix(CellMatrix matrix){
		this.cellMatrix = matrix;
	}

	public void setLSFrame(LSFrame frame){
		this.simFrame = frame;
	}

	public ArrayList<AST> getTypeStmts(){
		return typeStmts;

	}

	public ArrayList<AST> getWorldStmts(){
		return worldStmts;
	}

	public int getGenerations() {
		return generations;
	}

	public LSFrame getLSFrame(){
		return simFrame;	
	}

	public CellMatrix getCellMatrix(){
		return cellMatrix;
	}
	
	private Double interp(CreateStmt ast) {
		
		return null;	
	}
	private Double interp(KillStmt ast) {
		
		return null;	
	}
	private Double interp(PropertiesStmt ast) {
		simFrame = new LSFrame();
		int[] size = {10, 10};
		int[] coord = {5, 1};
		String[] types = {"block"};
		cellMatrix = new CellMatrix("block", size, coord, types);
		return null;	
	}
	private Double interp(AliveStmt ast) {
		System.out.println("setting a cell alive");
		cellMatrix.state(cellMatrix.ALIVE);
		return null;	
	}
	private Double interp(DeadStmt ast) {
		cellMatrix.state(cellMatrix.DEAD);
		return null;	
	}
	private Double interp(NeighborExpr ast) {
		return 0.0;	
	}
	private Double interp(NeighborsExpr ast) {
		// We're calling from inside a Type		
		if(ast.size() == 0) {
			return new Double(cellMatrix.neighborValues());
		}		
		// otherwise we're calling from somewhere else and process a coord
//		else
		return 0.0;	
	}
	private Double interp(NeighborhoodStmt ast) {
		
		return null;	
	}
	private Double interp(BooleanExpr ast) {
		return ast.value() == true ? 1.0 : 0.0;	
	}

	private Double interp(TypeStmt ast) {
		if(saveStmts) {
			typeStmts.add(ast);
			int[] neighborhood = {3, 4, 2, 1, 0, 0, 0};
			cellMatrix.addCellType("block", neighborhood, 4);
		}
		for (int i = 0; i < ast.size(); i++) {
			this.dispatch(ast.getAST(i));
		}
		return null;	
	}

	private Double interp(WorldStmt ast) {
		if(saveStmts)
			worldStmts.add(ast);
		for (int i = 0; i < ast.size(); i++) {
			this.dispatch(ast.getAST(i));
		}
		return null;	
	}

	private Double interp(ForStmt ast) {
		// First we check if the variable given at the start is the same as the one
		// we "next" at the end. If not, the syntax is wrong.
		String var = ast.startVar(), nexted = ast.endVar();
		if(!var.equals(nexted)){
			System.out.println("Variable in for loop (" + var + 
				") differs from one following next (" + nexted + "). Terminating.");
			System.exit(1);
		}
		// Now we get all the components for the For loop
		Double start = this.dispatch(ast.getAST(0));
		Double max = this.dispatch(ast.getAST(1));
		Double step = 1.0;
		if(ast.getAST(2) != null)
			step = this.dispatch(ast.getAST(2));
		System.out.println(step);
		for(int i = start.intValue(); i != max; i += step){
			memory.put(var, i);
			this.dispatch(ast.getAST(3)); 
		}
		return null;
	}

	// Spits out the prompt and uses the scanner to get input
	private Double interp(InputStmt ast) {
		// Print out the prompt
		System.out.print(dequote(ast.prompt()));
		int value = consoleInput.nextInt();
		// and assign it in the hashmap
		memory.put(ast.var(),value);
		return null;
	}

	private Double interp(EndStmt ast) {
		// The End statement just calls System.exit()
		System.exit(1);
		return null;
	}

	private Double interp(PrintStmt ast) {
		String value = "";	
		// Value will either be the value of an expression (and therefore has an AST)
		// or a given string (which indicates there is no AST)
		if(ast.size() > 0.0)
			value = this.dispatch(ast.getAST(0)).toString();
		else if(ast.text() != "")
			value = dequote(ast.text());
		System.out.print(value);
		return null;
	}

	// an EOLStmt always follows the series of PrintStmts generated in the print grammar/call
	private Double interp(EOLStmt ast) {
		System.out.println();
		return null;
	}

	// Helper method that simply removes the quotations from given strings in the language
	private String dequote(String val)
	{	
		int len = val.length();
		// if there are 2 characters, then there are only quotes => empty string
		if(len < 3)
			return "";
		return val.substring(1,len-1);
	}

/*** 


	All of these implementations were written by Lutz Hamel for SIMPLE1MULTI.


											***/

	//****** interpret statement level ASTs
	// statements
	private Double interp(AssignStmt ast) {
		// evaluate the expression
		Double value = this.dispatch(ast.getAST(0));
		// assign the value to the lhs var
		memory.put(ast.lhsVar(),value);

		// statements do not have return values -- null
		return null;
	}

	// block statements
	private Double interp(BlockStmt ast) {
		// interpret each of the statements in the block
		for (int i = 0; i < ast.size(); i++) {
		    this.dispatch(ast.getAST(i));
		}

		// statements do not have return values -- null
		return null;
	}

	// if statements
	private Double interp(IfStmt ast) {
		// interpret the expression
		Double value = this.dispatch(ast.getAST(0));
		if (value.doubleValue() != 0.0) {
		    // interpret the then clause
		    this.dispatch(ast.getAST(1));
		}
		else
		    // interpret the else clause if we have one
		    this.dispatch(ast.getAST(2));

		// statements do not have return values -- null
		return null;
	}

	// while statements
	private Double interp(WhileStmt ast) {
		Double value;

		// interpet the expression
		value = this.dispatch(ast.getAST(0));

		// interpret the loop while the expression value != 0.0
		while (value.doubleValue() != 0.0) {
		    // interpret the while body
		    this.dispatch(ast.getAST(1));
		    // reevaluate the loop expression
		    value = this.dispatch(ast.getAST(0));
		}

		// statements do not have return values -- null
		return null;
	}

	// statement lists
	private Double interp(StmtList ast) {
		// interpret each of the statements
		for (int i = 0; i < ast.size(); i++) {
		    this.dispatch(ast.getAST(i));
		}

		// statements do not have return values -- null
		return null;
	}


	//****** interpret expression level ASTs
	// binop expressions
	private Double interp(MathExpr ast) {
		// interpret left child
		Double left = this.dispatch(ast.getAST(0));
		// interpret right child
		Double right = this.dispatch(ast.getAST(1));

		// compute the return value based on the OP
		switch(ast.getOp()) {
		case MathExpr.ADD:
		    return new Double(left.doubleValue() + right.doubleValue());
		case MathExpr.MINUS:
		    return new Double(left.doubleValue() - right.doubleValue());
		case MathExpr.MULT:
		    return new Double(left.doubleValue() * right.doubleValue());
		case MathExpr.DIV:
		    return new Double(left.doubleValue() / right.doubleValue());
		case MathExpr.EQ:
		    return new Double((left.doubleValue() == right.doubleValue())?1.0:0.0);
		case MathExpr.LESSEQ:
		    return new Double((left.doubleValue() <= right.doubleValue())?1.0:0.0);
		case MathExpr.AND:
		    return new Double((left.intValue() * right.intValue()) != 0.0?1.0:0.0);
		case MathExpr.OR:
		    return new Double((left.intValue() + right.intValue()) != 0.0?1.0:0.0);
		default:
		    System.out.println("Interpreter  Visitor: unknown binary operator expression.");
		    System.exit(1);
		    return null;
		}
	}

	// Double expressions
	private Double interp(NumExpr ast) {
		return ast.getValue();
	}

	// parenthesized expressions
	private  Double interp(ParenExpr ast) {
		return this.dispatch(ast.getAST(0));
	}

	// rhs variable expressions
	private Double interp(VarExpr ast) {
		// fetch the variable value from memory
		Double v = (Double)memory.get(ast.rhsVar());

		// if not there, return 0.0
		if (v == null) 
		    return new Double(0.0);
		else
		    return v;
	}

	// negative expressions
	private  Double interp(NegExpr ast) {
		return this.dispatch(ast.getAST(0)) == 0.0 ? 1 : 0.0;
	}
}
